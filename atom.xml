<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Codehory&#39;s blog</title>
  
  <subtitle>格物要致知</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-30T12:47:25.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Codehory</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>4-快速找到未知长度单链表的中间结点（C++）</title>
    <link href="http://yoursite.com/2019/08/16/Leetcode(C++)/4-%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0%E6%9C%AA%E7%9F%A5%E9%95%BF%E5%BA%A6%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%EF%BC%88C++%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/16/Leetcode(C++)/4-快速找到未知长度单链表的中间结点（C++）/</id>
    <published>2019-08-15T16:25:16.000Z</published>
    <updated>2019-09-30T12:47:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给定一个未知长度的单链表，快速求得其中间节点"><a href="#给定一个未知长度的单链表，快速求得其中间节点" class="headerlink" title="给定一个未知长度的单链表，快速求得其中间节点"></a>给定一个未知长度的单链表，快速求得其中间节点</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：输入：1-&gt;3-&gt;5-&gt;3-&gt;9</span><br><span class="line">     输出：5</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>普通解法：要找到中间结点，首先想到的是通过遍历链表，得到链表的长度。再次遍历链表，找到长度一半的位置，即为解。时间复杂度为<code>O(3/2N)</code></p><p><strong>快慢指针法</strong>：定义两个指针p1，p2，均指向头结点。我们让p2的移动速度是p1的两倍。当p2指向尾结点时，p1指向的即为中间结点。时间复杂度为<code>O(1/2N)</code></p><a id="more"></a><h1 id="解：-快慢指针"><a href="#解：-快慢指针" class="headerlink" title="解：(快慢指针)"></a>解：(快慢指针)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findMidNode(ListNode *L) &#123;</span><br><span class="line">        ListNode *p1=L-&gt;next;       //链表包含头结点</span><br><span class="line">        ListNode *p2=L-&gt;next;</span><br><span class="line">        while(p2-&gt;next!=NULL)&#123;</span><br><span class="line">          if(p2-&gt;next-&gt;next!=NULL) &#123;</span><br><span class="line">              p2 = p2-&gt;next-&gt;next;</span><br><span class="line">              p1 = p1-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          else</span><br><span class="line">              p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return p1-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;给定一个未知长度的单链表，快速求得其中间节点&quot;&gt;&lt;a href=&quot;#给定一个未知长度的单链表，快速求得其中间节点&quot; class=&quot;headerlink&quot; title=&quot;给定一个未知长度的单链表，快速求得其中间节点&quot;&gt;&lt;/a&gt;给定一个未知长度的单链表，快速求得其中间节点&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例：输入：1-&amp;gt;3-&amp;gt;5-&amp;gt;3-&amp;gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     输出：5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;普通解法：要找到中间结点，首先想到的是通过遍历链表，得到链表的长度。再次遍历链表，找到长度一半的位置，即为解。时间复杂度为&lt;code&gt;O(3/2N)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;快慢指针法&lt;/strong&gt;：定义两个指针p1，p2，均指向头结点。我们让p2的移动速度是p1的两倍。当p2指向尾结点时，p1指向的即为中间结点。时间复杂度为&lt;code&gt;O(1/2N)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode（C++）" scheme="http://yoursite.com/categories/Leetcode%EF%BC%88C-%EF%BC%89/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>3-无重复字符的最长子串（C++）</title>
    <link href="http://yoursite.com/2019/08/01/Leetcode(C++)/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88C++%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/01/Leetcode(C++)/3-无重复字符的最长子串（C++）/</id>
    <published>2019-08-01T07:56:02.000Z</published>
    <updated>2019-09-30T12:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。"><a href="#给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。" class="headerlink" title="给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。"></a>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="思路-滑动窗口"><a href="#思路-滑动窗口" class="headerlink" title="思路:滑动窗口"></a>思路:滑动窗口</h1><p>建立一个256位大小的整型数组来代替哈希表，这样做的原因是ASCII表共能表示256个字符，所以可以记录所有字符，然后我们需要定义两个变量<code>len</code>和<code>left</code>，其中<code>len</code>用来记录最长无重复子串的长度，<code>left</code>指向该无重复子串左边的起始位置，然后我们遍历整个字符串，对于每一个遍历到的字符，如果哈希表中该字符串对应的值为0，说明没有遇到过该字符，则此时计算最长无重复子串，<code>i - left +１</code>，其中<code>ｉ</code>是最长无重复子串最右边的位置，left是最左边的位置，还有一种情况也需要计算最长无重复子串，就是当哈希表中的值小于<code>left</code>，这是由于此时出现过重复的字符，<code>left</code>的位置更新了，如果又遇到了新的字符，就要重新计算最长无重复子串。最后每次都要在哈希表中将当前字符对应的值赋值为<code>i+1</code>。</p><h1 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int table[256]=&#123;&#125;;</span><br><span class="line">        int left=0,len=0;</span><br><span class="line">        for(int i=0;i&lt;s.size();i++)&#123;</span><br><span class="line">            if(table[s[i]]==0||table[s[i]]&lt;left)&#123;</span><br><span class="line">                len=max(len,i-left+1);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                left=table[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            table[s[i]]=i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。&quot;&gt;&lt;a href=&quot;#给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。&quot; class=&quot;headerlink&quot; title=&quot;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&quot;&gt;&lt;/a&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;abcabcbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;bbbbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;pwwkew&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Leetcode（C++）" scheme="http://yoursite.com/categories/Leetcode%EF%BC%88C-%EF%BC%89/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2--两数相加（C++）</title>
    <link href="http://yoursite.com/2019/07/31/Leetcode(C++)/2--%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88C++%EF%BC%89/"/>
    <id>http://yoursite.com/2019/07/31/Leetcode(C++)/2--两数相加（C++）/</id>
    <published>2019-07-31T05:07:27.000Z</published>
    <updated>2019-09-30T12:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。"><a href="#给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。" class="headerlink" title="给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。"></a>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</h1><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong><code>示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></strong></p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>将两个链表看成是等长的链表相加，不足位的补0，例如：<code>75+6</code>,看成<code>75+06</code></li><li>每一位计算的要考虑上一位的进位问题，并缺当前位计算结束后同样需要更新进位值</li><li>两个链表各位相加完之后，如果最后的进位值为1，需要在链表上添加一个新的结点（1）</li></ul><h1 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1,ListNode* l2)&#123;</span><br><span class="line">        ListNode* pre=new ListNode(0);</span><br><span class="line">        ListNode* cur=pre;</span><br><span class="line">        ListNode* p1=l1,*p2=l2;</span><br><span class="line">        int carry=0;                     //进位值</span><br><span class="line">        while(p1!=NULL||p2!=NULL)&#123;</span><br><span class="line">            int x=(p1!=NULL)?p1-&gt;val:0;  //此位若为空，则补0</span><br><span class="line">            int y=(p2!=NULL)?p2-&gt;val:0;  //此位若为空，则补0</span><br><span class="line">            int sum=x+y+carry;</span><br><span class="line">            cur-&gt;next=new ListNode(sum%10);</span><br><span class="line">            carry=sum/10;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            if(p1!=NULL)</span><br><span class="line">                p1=p1-&gt;next;</span><br><span class="line">            if(p2!=NULL)</span><br><span class="line">                p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry&gt;0)</span><br><span class="line">            cur-&gt;next=new ListNode(carry); //添加结点1</span><br><span class="line">        return pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void printList(ListNode* l1)&#123;</span><br><span class="line">        ListNode* p=l1;</span><br><span class="line">        while(p!=NULL)&#123;</span><br><span class="line">            cout&lt;&lt;p-&gt;val&lt;&lt;&quot; &quot;;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;</span><br><span class="line">    ListNode* s1=new ListNode(5);</span><br><span class="line">    s1-&gt;next=new ListNode(7);</span><br><span class="line">    ListNode* s2=new ListNode(6);</span><br><span class="line">    Solution s;</span><br><span class="line">    s.printList(s.addTwoNumbers(s1,s2));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&quot;&gt;&lt;a href=&quot;#给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&quot; class=&quot;headerlink&quot; title=&quot;给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&quot;&gt;&lt;/a&gt;给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/h1&gt;&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;示例：
输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
输出：7 -&amp;gt; 0 -&amp;gt; 8
原因：342 + 465 = 807&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode（C++）" scheme="http://yoursite.com/categories/Leetcode%EF%BC%88C-%EF%BC%89/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>1-两数之和（C++）</title>
    <link href="http://yoursite.com/2019/07/28/Leetcode(C++)/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88C++%EF%BC%89/"/>
    <id>http://yoursite.com/2019/07/28/Leetcode(C++)/1-两数之和（C++）/</id>
    <published>2019-07-28T15:16:37.000Z</published>
    <updated>2019-09-30T12:45:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的那-两个-整数，并返回他们的数组下标。"><a href="#给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的那-两个-整数，并返回他们的数组下标。" class="headerlink" title="给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。"></a>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</h1><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><code>示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></p><a id="more"></a><h1 id="解1：暴力解法"><a href="#解1：暴力解法" class="headerlink" title="解1：暴力解法"></a>解1：暴力解法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; result_arry;</span><br><span class="line">        bool flag=false;</span><br><span class="line">        for (int i=0;i&lt;nums.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(flag)</span><br><span class="line">                break;</span><br><span class="line">            for(int j=i+1;j&lt;nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(target==nums[i]+nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    result_arry.push_back(i);</span><br><span class="line">                    result_arry.push_back(j);</span><br><span class="line">                    flag=true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result_arry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="解2-Map"><a href="#解2-Map" class="headerlink" title="解2:Map"></a>解2:Map</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int,int&gt; m;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            if(m.find(target-nums[i])!=m.end())&#123;</span><br><span class="line">                return &#123;m[target-nums[i]],i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                m[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的那-两个-整数，并返回他们的数组下标。&quot;&gt;&lt;a href=&quot;#给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的那-两个-整数，并返回他们的数组下标。&quot; class=&quot;headerlink&quot; title=&quot;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&quot;&gt;&lt;/a&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/h1&gt;&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;&lt;p&gt;&lt;code&gt;示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode（C++）" scheme="http://yoursite.com/categories/Leetcode%EF%BC%88C-%EF%BC%89/"/>
    
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Octomap在windows环境配置(任意版本VS)</title>
    <link href="http://yoursite.com/2019/07/27/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Octomap%E5%9C%A8windows%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE(%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACVS)/"/>
    <id>http://yoursite.com/2019/07/27/环境配置/Octomap在windows环境配置(任意版本VS)/</id>
    <published>2019-07-27T04:45:13.000Z</published>
    <updated>2019-09-30T10:09:29.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p><a href="[http://octomap.github.io/](http://octomap.github.io/">Octomap</a><br>是一种采用八叉树数据结构存储三维环境的概率占据地图。地图单元为体素（立方体）。对于Octomap，作者这里也不过多介绍了。相信你点开这里，对Octomap也有了大致的了解。</p><p>由于一些特殊需求，我们有时需要在windows环境下进行配置使用<code>Octomap</code>。关于这块，网上的教程鲜有，故写此篇供大家参考。</p><a id="more"></a><p><strong>此教程适用window下任意版本VS。</strong><br>作者这里使用的是：<code>VS2017</code> <code>win10</code> <code>octomap1.9.0</code></p><h1 id="编译Octomap"><a href="#编译Octomap" class="headerlink" title="编译Octomap"></a>编译Octomap</h1><ul><li><p>**安装<a href="[https://cmake.org/download/](https://cmake.org/download/">Cmake</a><br>点击链接下载安装包，并安装。</p></li><li><p>**下载<a href="[https://github.com/octomap/octomap/releases](https://github.com/octomap/octomap/releases">Octomap</a></p></li><li><strong>开始编译</strong><br>在Octomap根目录下新建<code>build</code>文件夹，<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp.jpg" alt></li></ul><p>打开Cmake，添加Octomap目录：1.根目录 2.build目录<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%281%29.jpg" alt></p><p>点击<code>Configure</code>，根据自己的VS版本选择，<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%282%29.jpg" alt><br>根据自己的平台选择，点<code>Finish</code><br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%283%29.jpg" alt></p><p>点击<code>Generate</code>。<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%284%29.jpg" alt><br>进入<code>octomap-1.9.0/build/</code>文件夹，用VS打开<code>ALL_BUILD.vcxproj</code>，选择<code>release</code>or<code>debug</code>,<code>win32</code>or<code>x64</code>（这里要与上面选择的平台一致）,右键解决方案栏里的<code>ALL_BUILD</code>的<code>重新生成</code>，最终显示全部生成成功。<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%285%29.jpg" alt><br>这样，在<code>octomap-1.9.0</code>文件夹中生成了<code>lib</code>文件夹<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%286%29.jpg" alt></p><h1 id="VS开发环境配置"><a href="#VS开发环境配置" class="headerlink" title="VS开发环境配置"></a>VS开发环境配置</h1><p>1.<strong>新建一个空项目</strong><br>2.<strong>菜单栏点击<code>视图-&gt;其他窗口-&gt;属性管理器</code></strong>，按照你上面的选择，选择<code>release</code>or<code>debug</code>,<code>win32</code>or<code>x64</code>，这里以<code>release|x64</code>为例，右键新建<strong><code>添加新项目属性表</code></strong>，取名<code>octomapconfig</code>,添加,<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%287%29.jpg" alt><br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%288%29.jpg" alt><br>3.<strong>双击新建的属性表</strong><br><strong><code>VC++ 目录-&gt;包含目录-&gt;</code></strong>添加头文件：(根据自己octomap的路径添加)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\Program Files\octomap-1.9.0\octomap\include</span><br><span class="line">E:\Program Files\octomap-1.9.0\octovis\include</span><br><span class="line">E:\Program Files\octomap-1.9.0\dynamicEDT3D\include</span><br></pre></td></tr></table></figure></p><p><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_config1.png" alt><br><strong><code>VC++ 目录-&gt;库目录-&gt;</code></strong>添加库文件：(根据自己octomap的路径添加)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Program Files\octomap-1.9.0\lib</span><br></pre></td></tr></table></figure></p><p><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%289%29.jpg" alt><br><strong><code>链接器-&gt;输入-&gt;附加依赖项</code></strong>添加lib文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dynamicedt3d.lib</span><br><span class="line">octomap.lib</span><br><span class="line">octomath.lib</span><br></pre></td></tr></table></figure></p><p><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%2810%29.jpg" alt><br>点击确定，配置完成。</p><h1 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;octomap/octomap.h&gt;</span><br><span class="line">#include &lt;octomap/OcTree.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace octomap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void print_query_info(point3d query, OcTreeNode* node) &#123;</span><br><span class="line"> if (node != NULL) &#123;</span><br><span class="line">  cout &lt;&lt; &quot;occupancy probability at &quot; &lt;&lt; query &lt;&lt; &quot;:\t &quot; &lt;&lt; node-&gt;getOccupancy() &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line">  cout &lt;&lt; &quot;occupancy probability at &quot; &lt;&lt; query &lt;&lt; &quot;:\t is unknown&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; &quot;generating example map&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"> OcTree tree(0.1);  // create empty tree with resolution 0.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // insert some measurements of occupied cells</span><br><span class="line"></span><br><span class="line"> for (int x = -20; x &lt; 20; x++) &#123;</span><br><span class="line">  for (int y = -20; y &lt; 20; y++) &#123;</span><br><span class="line">   for (int z = -20; z &lt; 20; z++) &#123;</span><br><span class="line">    point3d endpoint((float)x*0.05f, (float)y*0.05f, (float)z*0.05f);</span><br><span class="line">    tree.updateNode(endpoint, true); // integrate &apos;occupied&apos; measurement</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // insert some measurements of free cells</span><br><span class="line"></span><br><span class="line"> for (int x = -30; x &lt; 30; x++) &#123;</span><br><span class="line">  for (int y = -30; y &lt; 30; y++) &#123;</span><br><span class="line">   for (int z = -30; z &lt; 30; z++) &#123;</span><br><span class="line">    point3d endpoint((float)x*0.02f - 1.0f, (float)y*0.02f - 1.0f, (float)z*0.02f - 1.0f);</span><br><span class="line">    tree.updateNode(endpoint, false);  // integrate &apos;free&apos; measurement</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; &quot;performing some queries:&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"> point3d query(0., 0., 0.);</span><br><span class="line"> OcTreeNode* result = tree.search(query);</span><br><span class="line"> print_query_info(query, result);</span><br><span class="line"></span><br><span class="line"> query = point3d(-1., -1., -1.);</span><br><span class="line"> result = tree.search(query);</span><br><span class="line"> print_query_info(query, result);</span><br><span class="line"></span><br><span class="line"> query = point3d(1., 1., 1.);</span><br><span class="line"> result = tree.search(query);</span><br><span class="line"> print_query_info(query, result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> tree.writeBinary(&quot;simple_tree.bt&quot;);</span><br><span class="line"> cout &lt;&lt; &quot;wrote example file simple_tree.bt&quot; &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; &quot;now you can use octovis to visualize: octovis simple_tree.bt&quot; &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; &quot;Hint: hit &apos;F&apos;-key in viewer to see the freespace&quot; &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果生成成功，运行没有问题，表明配置成功！</p><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p>如果测试程序生成出现这样的报错，<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%2811%29.jpg" alt><br><strong>解决办法：</strong><br><strong><code>项目-&gt;属性-&gt;C/C++-&gt;语言-&gt;符合模式-&gt;否</code></strong></p><p><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-config/octomap_configwebp%20%2812%29.jpg" alt></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong><em>至此，相信你也和我一样，已经配置成功了。</em></strong><br><strong><em>如有任何问题或是书写纰漏，请给我留言，我会帮你们耐心解决。</em></strong><br><strong><em>感谢观看，希望对你们有所帮助！</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;[http://octomap.github.io/](http://octomap.github.io/&quot;&gt;Octomap&lt;/a&gt;&lt;br&gt;是一种采用八叉树数据结构存储三维环境的概率占据地图。地图单元为体素（立方体）。对于Octomap，作者这里也不过多介绍了。相信你点开这里，对Octomap也有了大致的了解。&lt;/p&gt;&lt;p&gt;由于一些特殊需求，我们有时需要在windows环境下进行配置使用&lt;code&gt;Octomap&lt;/code&gt;。关于这块，网上的教程鲜有，故写此篇供大家参考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="环境配置" scheme="http://yoursite.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="配置踩坑" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/"/>
    
      <category term="Octomap" scheme="http://yoursite.com/tags/Octomap/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github博客搭建与备份教程（详细篇）</title>
    <link href="http://yoursite.com/2019/07/25/%E7%8E%A9%E8%BD%AChexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%A4%87%E4%BB%BD%E6%95%99%E7%A8%8B%EF%BC%88%E8%AF%A6%E7%BB%86%E7%AF%87%EF%BC%89/"/>
    <id>http://yoursite.com/2019/07/25/玩转hexo/hexo+github博客搭建与备份教程（详细篇）/</id>
    <published>2019-07-25T04:17:56.000Z</published>
    <updated>2019-09-30T09:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自肥宅的小乐趣，带你玩转hexo自建博客，生活还是需要装一下的嘛：）。</p><h1 id="About-Hexo"><a href="#About-Hexo" class="headerlink" title="About Hexo"></a>About Hexo</h1><p><strong>官网</strong>:<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><p>关于hexo，如官网的一句话介绍,</p><blockquote><p><em>Hexo 是一个快速、简洁且高效的博客框架。</em></p></blockquote><ul><li><p><strong>hexo是基于node.js制作的一个博客工具，利用markdown编写文章，hexo生成静态html页面，最后将生成的html上传到我们自己的服务器。</strong></p></li><li><p><strong>hexo提供了多种样式的主题，这也是吸引众多热爱DIY的小伙伴的地方，再也不用拘泥于统一制式了。</strong></p></li></ul><a id="more"></a><h1 id="github-hexo"><a href="#github-hexo" class="headerlink" title="github+hexo"></a>github+hexo</h1><p>正如上面的介绍，hexo会在本地生成一个静态html页面，为了让别人看到我们的博客，我们就需要将其推到远端—服务器。</p><p>那么github就提供给我们一个免费的仓库，对于新人练手是再好不过了。当然，也可以购买属于自己的域名，让更多的朋友看到你的博客。话不多说，让我们开始吧！（作者使用的是mac os系统，其他系统也类似）</p><hr><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h3><p>mac用户推荐使用<code>Homebrew</code></p><ul><li><p><strong>安装Homebrew</strong><br><a href="[https://brew.sh/](https://brew.sh/">Homebrew</a><br>)是一款Mac OS平台下的软件包管理工具,类似于ubuntu的<code>apt-get</code>。如没安装的请先安装，打开终端，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>安装node.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install node</span><br></pre></td></tr></table></figure></li><li><p><strong>查看是否安装成功</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure></li></ul><p>笔者安装的版本为v12.6.0</p><h3 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure><h3 id="3-安装cnpm"><a href="#3-安装cnpm" class="headerlink" title="3.安装cnpm"></a>3.安装cnpm</h3><p>安装hexo需要依赖node.js的<code>npm</code>的包管理器，由于国内镜像源速度很慢，为了避免出错，所以在使用之前一般是利用<code>npm</code>来安装<code>cnpm</code>,<code>cnpm</code>为淘宝的镜像源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry-https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><hr><h1 id="hexo博客框架搭建"><a href="#hexo博客框架搭建" class="headerlink" title="hexo博客框架搭建"></a>hexo博客框架搭建</h1><ul><li><p><strong>一切就绪，准备安装hexo</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p><strong>检查版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure></li><li><p><strong>创建存放博客的文件夹</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir myblog &amp;&amp; cd myblog</span><br></pre></td></tr></table></figure></li><li><p><strong>生成博客</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></li></ul><p>至此，我们hexo的博客搭建初步完成了。<strong>INFO  Start blogging with Hexo!</strong></p><ul><li><p><strong>启动博客</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li><li><p><strong>在浏览器地址栏处输入：</strong><a href="https://localhost:4000" target="_blank" rel="noopener">https://localhost:4000</a> ，<strong>就可以看到博客的雏形了。(ctrl+C关闭博客)</strong></p></li></ul><p><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp.jpg" alt></p><hr><h2 id="部署至Github"><a href="#部署至Github" class="headerlink" title="部署至Github"></a>部署至Github</h2><ol><li><strong>创建新仓库（没有github账号的请先注册）Creat new repository,<br>地址填写格式：<code>username.github.io</code>,注：”username”必须与你的github账号的ID一致。</strong><br><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%281%29.jpg" alt><br>2.<strong>配置SSH Key</strong><br><code>SSH Key</code>被认为是一种更安全的登陆方式，在每次更新博客时无需输入用户名和密码，更加方便、快捷、安全。</li></ol><ul><li><strong>查看本机是否存在SSH密钥</strong><br>打开终端(home目录下)，输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd .ssh</span><br></pre></td></tr></table></figure></li></ul><p>若不存在，请进行下一步（存在，请跳过创建步骤）</p><ul><li><strong>创建SSH Key</strong><br><code>your_email@example.com</code>填写你的邮箱地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></li></ul><p>输入后按回车，然后会提示输入密码，可以按回车设为空。之后SSH就生成了，下图所示：<br><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%282%29.jpg" alt><br>3.<strong>在Github中添加密钥</strong><br>以文本形式打开<code>.ssh</code>中的<code>id_rsa.pub</code>文件，复制内容，接着登陆Github，点击右上角头像<code>Setting-&gt;SSH and GPG keys-&gt;New SSH key-&gt;粘贴Key（Title任意填写）-&gt;Add SSH key</code> 没问题，Bingo！</p><p>4.<strong>检验SSH Key</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>执行yes，若出现下例，则表示配置成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi codehory! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p><p>5.<strong>设置用户信息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;codehory&quot;//自己喜欢的用户名（非github用户名）</span><br><span class="line">$ git config --global user.email  &quot;codehory@gmail.com&quot;//填写自己的邮箱</span><br></pre></td></tr></table></figure></p><p>6.<strong>本地博客部署至Github</strong><br>终端<code>myblog</code>目录下，使用<code>vim</code>打开<code>_config.yml</code>,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure></p><p>滑动至最底部，如图，编辑 <code>deploy</code>节点,<br><code>type: git</code><br><code>repo: git@github.com:codehory/codehory.github.io.git</code><br><code>branch: master</code><br><strong>注：1.冒号后有空格 2.<code>repo</code>一行为新建仓库的SSH地址，打开新建仓库就能看见</strong></p><p><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%283%29.jpg" alt></p><p><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%284%29.jpg" alt></p><p>输入完毕，按<code>esc</code>,<code>:wq</code>保存退出。</p><p>7.<strong>安装部署插件</strong><br>在<code>myblog</code>目录下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>8.<strong>Deploy to Github</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure></p><p>至此，恭喜，完成全部部署，在网址栏输入：<code>yourusername.github.io</code>就能看到你的初步博客啦！（<code>yourusername</code>为你github用户名）</p><hr><h2 id="如何写一篇博客"><a href="#如何写一篇博客" class="headerlink" title="如何写一篇博客"></a>如何写一篇博客</h2><p>在<code>myblog</code>目录下，新建一篇博客，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;my first hexo blog&quot;</span><br></pre></td></tr></table></figure></p><p>在本地博客的<code>source-&gt;_posts</code>路径下看到新建的文章，是md格式的，使用markdown文本编辑器进行编辑即可。</p><p>编辑完成之后，执行以下命令，即可更新博文，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure></p><hr><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>为了继续满足我们深入骨髓的DIY之心，换一个自己喜欢的主题也是必不可少的环节。Github上有很多眼花缭乱的主题，去选一个自己喜欢的吧！<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>本文例程使用的是： <a href="https://link.jianshu.com/?t=https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a></p><ul><li><p><strong>在<code>myblog</code>目录下，下载我们喜欢的主题至<code>themes</code>下，</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure></li><li><p><strong>配置通用文件</strong></p></li></ul><p>在<code>myblog</code>目录下，用<code>vim</code>打开<code>_config.yml</code>,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure></p><p>可以修改<code>title,subtitle,description,keywords,author</code>等内容，这些属性依赖于你选择的主题。<br><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%285%29.jpg" alt><br>添加对应的主题，<code>theme:对应主题名</code><br><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%286%29.jpg" alt></p><p>输入完毕，按<code>esc</code>,<code>:wq</code>保存退出。</p><ul><li><strong>配置主题文件</strong><br>在<code>./themes/yilia</code>目录下,用<code>vim</code>打开<code>_config.yml</code>文件(这是每个主题对应的配置文件),<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure></li></ul><p><code>menu</code>用来设置你博客的分类，标签等。<br><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%287%29.jpg" alt></p><p><code>subnav</code>为你的社交媒体的链接，如github，微博等。<br><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%288%29.jpg" alt><br><code>打赏</code>功能可以设置打赏用语”谢谢你请我吃糖果”。<code>插入图片设置与下面头像设置一并介绍</code><br><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%289%29.jpg" alt></p><p><strong>用github当图床</strong><br><code>头像</code>更换:在<code>myblog</code>目录下的<code>source</code>文件下创建<code>img</code>文件，将图片保存在其中。我们通过部署生成，把图片放到<code>github</code>上，通过链接找到。<br>例如：本文将一张<code>timg.jpeg</code>的图片存放到<code>myblog/source/img/</code>下，那么我们可以通过之前生成的链接，如<code>https://codehory.github.io/img/timg.jpeg</code>,进行图片的插入。</p><p><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%2810%29.jpg" alt></p><p>还有许多诸如此类的设置，各自进去修改吧，同样的操作，保存退出。</p><ul><li><strong>上传更新</strong><br>配置完毕，我们需要重新生成博客，并将博客更新到远端。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure></li></ul><p>最后来看看我们的博客吧，还不错吧：<br><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%2811%29.jpg" alt></p><hr><h2 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h2><p>由于博客是在本地生成的，如果更换电脑，那我们是不是就不能用这个博客了？方法总比问题多，我们可以利用<code>github</code>来备份博客的文件和数据。</p><ul><li><p><strong>创建版本库</strong><br>在<code>myblog</code>目录下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p><strong>在Github上新建仓库</strong><br>新建一个仓库，将<code>Repository name</code>取为<code>blog.git</code><br><img src="http://pyklc92mt.bkt.clouddn.com/image/hexo/hexo_buildwebp%20%2812%29.jpg" alt></p></li><li><p><strong>链接仓库</strong><br>链接仓库地址：<code>git@github.com:yourusername/blog.git</code>(<code>yourusername</code>为你github用户名)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:codehory/blog.git</span><br></pre></td></tr></table></figure></li><li><p><strong>添加备份文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add source/ themes/ _config.yml scaffolds/ package.json .gitignore</span><br></pre></td></tr></table></figure></li><li><p><strong>注释备份内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;博客备份&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>第一次强制上传文件到github仓库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure></li></ul><p>第一次备份完毕，以后的备份，只需进行如下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p><p>这样备份完毕后，我们在另一台电脑上，只需<code>git clone</code>一下就行了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong><em>说长不长，说短不短，一通操作下来，不知你是否成功了呢？作者只是抛砖引玉，带你入门，之后的进阶过程，还望各位继续探索，玩转hexo。欢迎在评论区展示下你们的成果咯，让作者也学习学习，哈哈。同样，如若有任何纰漏或者相关问题，请在评论区留言吧！感谢各位观看！See you～</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自肥宅的小乐趣，带你玩转hexo自建博客，生活还是需要装一下的嘛：）。&lt;/p&gt;&lt;h1 id=&quot;About-Hexo&quot;&gt;&lt;a href=&quot;#About-Hexo&quot; class=&quot;headerlink&quot; title=&quot;About Hexo&quot;&gt;&lt;/a&gt;About Hexo&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;官网&lt;/strong&gt;:&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hexo.io/zh-cn/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;关于hexo，如官网的一句话介绍,&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Hexo 是一个快速、简洁且高效的博客框架。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;hexo是基于node.js制作的一个博客工具，利用markdown编写文章，hexo生成静态html页面，最后将生成的html上传到我们自己的服务器。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;hexo提供了多种样式的主题，这也是吸引众多热爱DIY的小伙伴的地方，再也不用拘泥于统一制式了。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="玩转hexo" scheme="http://yoursite.com/categories/%E7%8E%A9%E8%BD%AChexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>VS2017配置PCL1-9-1-for-win10(超详细)</title>
    <link href="http://yoursite.com/2019/06/07/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/VS2017%E9%85%8D%E7%BD%AEPCL1-9-1-for-win10(%E8%B6%85%E8%AF%A6%E7%BB%86)/"/>
    <id>http://yoursite.com/2019/06/07/环境配置/VS2017配置PCL1-9-1-for-win10(超详细)/</id>
    <published>2019-06-07T13:27:45.000Z</published>
    <updated>2019-09-30T09:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者经历了从PCL1.7-PCL1.9,VS2013-VS2017的反复配置，其过程是坎坷与辛酸，踩过各种坑，现在配置起来真的是炉火纯青了。现在又来台新电脑了，没错，再来配置一次吧。此次配置VS2017+PCL1.9.1</p><hr><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>VS2017 自行下载</li><li><a href="[https://github.com/PointCloudLibrary/pcl/releases](https://github.com/PointCloudLibrary/pcl/releases">PCL1.9.1</a><br>点击链接跳转Github下载，根据自己的环境选择 <code>win64</code>或<code>win32</code>,作者下载的是：<code>PCL-1.9.1-AllInOne-msvc2017-win64.exe</code><br><code>pcl-1.9.1-pdb-msvc2017-win64.zip</code></li></ul><a id="more"></a><h1 id="安装PCL"><a href="#安装PCL" class="headerlink" title="安装PCL"></a>安装PCL</h1><p>双击点开<code>PCL-1.9.1-AllInOne-msvc2017-win64.exe</code>，选择<code>Add PCL to the system PATH for all users</code>,<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp.jpg" alt><br>更改安装路径，<code>E:\Program Files\PCL 1.9.1</code>,<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%281%29.jpg" alt><br>选择第三方库，这里作者全选，开始安装，<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%282%29.jpg" alt><br>中途跳出OpenNI安装，选择路径<code>./3rdParty/OpenNI2/</code>,安装，</p><p><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%283%29.jpg" alt><br>安装完毕。</p><p>解压<code>pcl-1.9.1-pdb-msvc2017-win64.zip</code>，将PDB文件拷贝到PCL安装路径下的bin文件夹中。</p><hr><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ul><li><strong>系统环境配置</strong><br><code>计算机-&gt;属性-&gt;高级系统变量-&gt;环境变量</code>，双击<code>Path</code>，<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%284%29.jpg" alt></li></ul><p><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%285%29.jpg" alt><br>添加如下路径(路径根据自己的安装目录添加)<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%286%29.jpg" alt><br>添加完毕后，电脑注销后生效。</p><ul><li><strong>VS开发环境配置</strong></li></ul><ol><li><strong>打开VS2017，新建空项目</strong></li></ol><p>2.<strong>菜单栏点击<code>视图-&gt;其他窗口-&gt;属性管理器</code></strong>，选择<code>release</code>or<code>debug</code>,<code>win32</code>or<code>x64</code>，这里以<code>release|x64</code>为例，右键新建<strong><code>添加新项目属性表</code></strong>，取名<code>config</code>,添加，<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%287%29.jpg" alt><br>3.<strong>双击新建的属性表</strong><br><strong><code>VC++ 目录-&gt;包含目录-&gt;</code></strong>添加头文件：(根据自己pcl的路径添加)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E:\Program Files\PCL 1.9.1\include\pcl-1.9</span><br><span class="line">E:\Program Files\PCL 1.9.1\3rdParty\Boost\include\boost-1_68</span><br><span class="line">E:\Program Files\PCL 1.9.1\3rdParty\Eigen\eigen3</span><br><span class="line">E:\Program Files\PCL 1.9.1\3rdParty\FLANN\include</span><br><span class="line">E:\Program Files\PCL 1.9.1\3rdParty\OpenNI2\Include</span><br><span class="line">E:\Program Files\PCL 1.9.1\3rdParty\Qhull\include</span><br><span class="line">E:\Program Files\PCL 1.9.1\3rdParty\VTK\include\vtk-8.1</span><br></pre></td></tr></table></figure></p><p><strong><code>VC++ 目录-&gt;库目录-&gt;</code></strong>添加库文件：(根据自己pcl的路径添加)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E:\Program Files\PCL 1.9.1\lib</span><br><span class="line">E:\Program Files\PCL 1.9.1\3rdParty\Boost\lib</span><br><span class="line">E:\Program Files\PCL 1.9.1\3rdParty\FLANN\lib</span><br><span class="line">E:\Program Files\PCL 1.9.1\3rdParty\OpenNI2\Lib</span><br><span class="line">E:\Program Files\PCL 1.9.1\3rdParty\Qhull\lib</span><br><span class="line">E:\Program Files\PCL 1.9.1\3rdParty\VTK\lib</span><br></pre></td></tr></table></figure></p><p><strong><code>链接器-&gt;输入-&gt;附加依赖项</code></strong>添加lib文件：(这里是<code>release</code>版本),如果你上面选择的是<code>debug win32</code> or <code>debug x64</code>,则添加<code>debug</code>版本的<code>lib</code>文件，请看下面的<code>Tips</code>,教你如何获取<code>lib</code>目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">pcl_common_release.lib</span><br><span class="line">pcl_features_release.lib</span><br><span class="line">pcl_filters_release.lib</span><br><span class="line">pcl_io_ply_release.lib</span><br><span class="line">pcl_io_release.lib</span><br><span class="line">pcl_kdtree_release.lib</span><br><span class="line">pcl_keypoints_release.lib</span><br><span class="line">pcl_ml_release.lib</span><br><span class="line">pcl_octree_release.lib</span><br><span class="line">pcl_outofcore_release.lib</span><br><span class="line">pcl_people_release.lib</span><br><span class="line">pcl_recognition_release.lib</span><br><span class="line">pcl_registration_release.lib</span><br><span class="line">pcl_sample_consensus_release.lib</span><br><span class="line">pcl_search_release.lib</span><br><span class="line">pcl_segmentation_release.lib</span><br><span class="line">pcl_stereo_release.lib</span><br><span class="line">pcl_surface_release.lib</span><br><span class="line">pcl_tracking_release.lib</span><br><span class="line">pcl_visualization_release.lib</span><br><span class="line">libboost_atomic-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_bzip2-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_chrono-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_container-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_context-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_contract-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_coroutine-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_date_time-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_exception-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_fiber-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_filesystem-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_graph-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_graph_parallel-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_iostreams-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_locale-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_log-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_log_setup-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_math_c99-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_math_c99f-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_math_c99l-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_math_tr1-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_math_tr1f-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_math_tr1l-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_mpi-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_numpy27-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_numpy37-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_prg_exec_monitor-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_program_options-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_python27-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_python37-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_random-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_regex-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_serialization-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_signals-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_stacktrace_noop-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_stacktrace_windbg-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_stacktrace_windbg_cached-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_system-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_test_exec_monitor-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_thread-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_timer-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_type_erasure-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_unit_test_framework-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_wave-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_wserialization-vc141-mt-x64-1_68.lib</span><br><span class="line">libboost_zlib-vc141-mt-x64-1_68.lib</span><br><span class="line">OpenNI2.lib</span><br><span class="line">flann.lib</span><br><span class="line">flann_cpp.lib</span><br><span class="line">flann_cpp_s.lib</span><br><span class="line">flann_s.lib</span><br><span class="line">qhull.lib</span><br><span class="line">qhullcpp.lib</span><br><span class="line">qhullstatic.lib</span><br><span class="line">qhullstatic_r.lib</span><br><span class="line">qhull_p.lib</span><br><span class="line">qhull_r.lib</span><br><span class="line">vtkalglib-8.1.lib</span><br><span class="line">vtkChartsCore-8.1.lib</span><br><span class="line">vtkCommonColor-8.1.lib</span><br><span class="line">vtkCommonComputationalGeometry-8.1.lib</span><br><span class="line">vtkCommonCore-8.1.lib</span><br><span class="line">vtkCommonDataModel-8.1.lib</span><br><span class="line">vtkCommonExecutionModel-8.1.lib</span><br><span class="line">vtkCommonMath-8.1.lib</span><br><span class="line">vtkCommonMisc-8.1.lib</span><br><span class="line">vtkCommonSystem-8.1.lib</span><br><span class="line">vtkCommonTransforms-8.1.lib</span><br><span class="line">vtkDICOMParser-8.1.lib</span><br><span class="line">vtkDomainsChemistry-8.1.lib</span><br><span class="line">vtkexoIIc-8.1.lib</span><br><span class="line">vtkexpat-8.1.lib</span><br><span class="line">vtkFiltersAMR-8.1.lib</span><br><span class="line">vtkFiltersCore-8.1.lib</span><br><span class="line">vtkFiltersExtraction-8.1.lib</span><br><span class="line">vtkFiltersFlowPaths-8.1.lib</span><br><span class="line">vtkFiltersGeneral-8.1.lib</span><br><span class="line">vtkFiltersGeneric-8.1.lib</span><br><span class="line">vtkFiltersGeometry-8.1.lib</span><br><span class="line">vtkFiltersHybrid-8.1.lib</span><br><span class="line">vtkFiltersHyperTree-8.1.lib</span><br><span class="line">vtkFiltersImaging-8.1.lib</span><br><span class="line">vtkFiltersModeling-8.1.lib</span><br><span class="line">vtkFiltersParallel-8.1.lib</span><br><span class="line">vtkFiltersParallelImaging-8.1.lib</span><br><span class="line">vtkFiltersPoints-8.1.lib</span><br><span class="line">vtkFiltersProgrammable-8.1.lib</span><br><span class="line">vtkFiltersSelection-8.1.lib</span><br><span class="line">vtkFiltersSMP-8.1.lib</span><br><span class="line">vtkFiltersSources-8.1.lib</span><br><span class="line">vtkFiltersStatistics-8.1.lib</span><br><span class="line">vtkFiltersTexture-8.1.lib</span><br><span class="line">vtkFiltersTopology-8.1.lib</span><br><span class="line">vtkFiltersVerdict-8.1.lib</span><br><span class="line">vtkfreetype-8.1.lib</span><br><span class="line">vtkGeovisCore-8.1.lib</span><br><span class="line">vtkgl2ps-8.1.lib</span><br><span class="line">vtkhdf5-8.1.lib</span><br><span class="line">vtkhdf5_hl-8.1.lib</span><br><span class="line">vtkImagingColor-8.1.lib</span><br><span class="line">vtkImagingCore-8.1.lib</span><br><span class="line">vtkImagingFourier-8.1.lib</span><br><span class="line">vtkImagingGeneral-8.1.lib</span><br><span class="line">vtkImagingHybrid-8.1.lib</span><br><span class="line">vtkImagingMath-8.1.lib</span><br><span class="line">vtkImagingMorphological-8.1.lib</span><br><span class="line">vtkImagingSources-8.1.lib</span><br><span class="line">vtkImagingStatistics-8.1.lib</span><br><span class="line">vtkImagingStencil-8.1.lib</span><br><span class="line">vtkInfovisCore-8.1.lib</span><br><span class="line">vtkInfovisLayout-8.1.lib</span><br><span class="line">vtkInteractionImage-8.1.lib</span><br><span class="line">vtkInteractionStyle-8.1.lib</span><br><span class="line">vtkInteractionWidgets-8.1.lib</span><br><span class="line">vtkIOAMR-8.1.lib</span><br><span class="line">vtkIOCore-8.1.lib</span><br><span class="line">vtkIOEnSight-8.1.lib</span><br><span class="line">vtkIOExodus-8.1.lib</span><br><span class="line">vtkIOExport-8.1.lib</span><br><span class="line">vtkIOExportOpenGL-8.1.lib</span><br><span class="line">vtkIOGeometry-8.1.lib</span><br><span class="line">vtkIOImage-8.1.lib</span><br><span class="line">vtkIOImport-8.1.lib</span><br><span class="line">vtkIOInfovis-8.1.lib</span><br><span class="line">vtkIOLegacy-8.1.lib</span><br><span class="line">vtkIOLSDyna-8.1.lib</span><br><span class="line">vtkIOMINC-8.1.lib</span><br><span class="line">vtkIOMovie-8.1.lib</span><br><span class="line">vtkIONetCDF-8.1.lib</span><br><span class="line">vtkIOParallel-8.1.lib</span><br><span class="line">vtkIOParallelXML-8.1.lib</span><br><span class="line">vtkIOPLY-8.1.lib</span><br><span class="line">vtkIOSQL-8.1.lib</span><br><span class="line">vtkIOTecplotTable-8.1.lib</span><br><span class="line">vtkIOVideo-8.1.lib</span><br><span class="line">vtkIOXML-8.1.lib</span><br><span class="line">vtkIOXMLParser-8.1.lib</span><br><span class="line">vtkjpeg-8.1.lib</span><br><span class="line">vtkjsoncpp-8.1.lib</span><br><span class="line">vtklibharu-8.1.lib</span><br><span class="line">vtklibxml2-8.1.lib</span><br><span class="line">vtklz4-8.1.lib</span><br><span class="line">vtkmetaio-8.1.lib</span><br><span class="line">vtkNetCDF-8.1.lib</span><br><span class="line">vtknetcdfcpp-8.1.lib</span><br><span class="line">vtkoggtheora-8.1.lib</span><br><span class="line">vtkParallelCore-8.1.lib</span><br><span class="line">vtkpng-8.1.lib</span><br><span class="line">vtkproj4-8.1.lib</span><br><span class="line">vtkRenderingAnnotation-8.1.lib</span><br><span class="line">vtkRenderingContext2D-8.1.lib</span><br><span class="line">vtkRenderingContextOpenGL-8.1.lib</span><br><span class="line">vtkRenderingCore-8.1.lib</span><br><span class="line">vtkRenderingFreeType-8.1.lib</span><br><span class="line">vtkRenderingGL2PS-8.1.lib</span><br><span class="line">vtkRenderingImage-8.1.lib</span><br><span class="line">vtkRenderingLabel-8.1.lib</span><br><span class="line">vtkRenderingLIC-8.1.lib</span><br><span class="line">vtkRenderingLOD-8.1.lib</span><br><span class="line">vtkRenderingOpenGL-8.1.lib</span><br><span class="line">vtkRenderingVolume-8.1.lib</span><br><span class="line">vtkRenderingVolumeOpenGL-8.1.lib</span><br><span class="line">vtksqlite-8.1.lib</span><br><span class="line">vtksys-8.1.lib</span><br><span class="line">vtktiff-8.1.lib</span><br><span class="line">vtkverdict-8.1.lib</span><br><span class="line">vtkViewsContext2D-8.1.lib</span><br><span class="line">vtkViewsCore-8.1.lib</span><br><span class="line">vtkViewsInfovis-8.1.lib</span><br><span class="line">vtkzlib-8.1.lib</span><br></pre></td></tr></table></figure></p><p><strong>Tips</strong>：如何获得<code>lib</code>目录？<br>举个例子：我们要获得<code>.\PCL 1.9.1\lib</code>目录下的<code>lib目录</code>，在此文件夹下新建一个<code>.txt</code>文本，在文本中写入下列代码，保存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /b *debug.lib&gt;1.txt</span><br></pre></td></tr></table></figure></p><p>将文本后缀名<code>.txt</code>改为<code>.bat</code>，运行脚本，<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%288%29.jpg" alt><br>在目录下会生成<code>1.txt</code>，打开即为<code>lib</code>目录（这里提取的是<code>debug</code>目录，如需<code>release</code>，只需修改代码，<code>dir /b *release.lib&gt;1.txt</code>）。<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%289%29.jpg" alt></p><p>至此，配置完成！</p><h1 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;pcl/io/pcd_io.h&gt;</span><br><span class="line">#include &lt;pcl/point_types.h&gt;</span><br><span class="line">#include &lt;pcl/ModelCoefficients.h&gt;</span><br><span class="line">#include &lt;pcl/filters/project_inliers.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);</span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_projected(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);</span><br><span class="line"></span><br><span class="line">// Fill in the cloud data</span><br><span class="line">cloud-&gt;width = 5;</span><br><span class="line">cloud-&gt;height = 1;</span><br><span class="line">cloud-&gt;points.resize(cloud-&gt;width * cloud-&gt;height);</span><br><span class="line"></span><br><span class="line">for (size_t i = 0; i &lt; cloud-&gt;points.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">cloud-&gt;points[i].x = 1024 * rand() / (RAND_MAX + 1.0f);</span><br><span class="line">cloud-&gt;points[i].y = 1024 * rand() / (RAND_MAX + 1.0f);</span><br><span class="line">cloud-&gt;points[i].z = 1024 * rand() / (RAND_MAX + 1.0f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cerr &lt;&lt; &quot;Cloud before projection: &quot; &lt;&lt; std::endl;</span><br><span class="line">for (size_t i = 0; i &lt; cloud-&gt;points.size(); ++i)</span><br><span class="line">std::cerr &lt;&lt; &quot;    &quot; &lt;&lt; cloud-&gt;points[i].x &lt;&lt; &quot; &quot;</span><br><span class="line">&lt;&lt; cloud-&gt;points[i].y &lt;&lt; &quot; &quot;</span><br><span class="line">&lt;&lt; cloud-&gt;points[i].z &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">// Create a set of planar coefficients with X=Y=0,Z=1</span><br><span class="line">pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients());</span><br><span class="line">coefficients-&gt;values.resize(4);</span><br><span class="line">coefficients-&gt;values[0] = coefficients-&gt;values[1] = 0;</span><br><span class="line">coefficients-&gt;values[2] = 1.0;</span><br><span class="line">coefficients-&gt;values[3] = 0;</span><br><span class="line"></span><br><span class="line">// Create the filtering object</span><br><span class="line">pcl::ProjectInliers&lt;pcl::PointXYZ&gt; proj;</span><br><span class="line">proj.setModelType(pcl::SACMODEL_PLANE);</span><br><span class="line">proj.setInputCloud(cloud);</span><br><span class="line">proj.setModelCoefficients(coefficients);</span><br><span class="line">proj.filter(*cloud_projected);</span><br><span class="line"></span><br><span class="line">std::cerr &lt;&lt; &quot;Cloud after projection: &quot; &lt;&lt; std::endl;</span><br><span class="line">for (size_t i = 0; i &lt; cloud_projected-&gt;points.size(); ++i)</span><br><span class="line">std::cerr &lt;&lt; &quot;    &quot; &lt;&lt; cloud_projected-&gt;points[i].x &lt;&lt; &quot; &quot;</span><br><span class="line">&lt;&lt; cloud_projected-&gt;points[i].y &lt;&lt; &quot; &quot;</span><br><span class="line">&lt;&lt; cloud_projected-&gt;points[i].z &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果生成成功，并能运行得到结果，表明配置成功！<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%2810%29.jpg" alt></p><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p>如果出现如下报错，<br><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%2811%29.jpg" alt><br><strong>解决方法：</strong><br>双击自己建的属性表，<strong><code>C/C++ -&gt; 预处理器 -&gt; 预处理器定义</code></strong>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_CRT_SECURE_NO_WARNINGS</span><br><span class="line">_SCL_SECURE_NO_WARNINGS</span><br><span class="line">_SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING</span><br></pre></td></tr></table></figure></p><p><img src="http://pyklc92mt.bkt.clouddn.com/image/environment-configwebp%20%2812%29.jpg" alt></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong><em>至此，相信你也和我一样，已经配置成功了。<br>如有任何问题或是书写纰漏，请给我留言，我会帮你们耐心解决。<br>感谢观看，希望对你们有所帮助！</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者经历了从PCL1.7-PCL1.9,VS2013-VS2017的反复配置，其过程是坎坷与辛酸，踩过各种坑，现在配置起来真的是炉火纯青了。现在又来台新电脑了，没错，再来配置一次吧。此次配置VS2017+PCL1.9.1&lt;/p&gt;&lt;hr&gt;&lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;VS2017 自行下载&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;[https://github.com/PointCloudLibrary/pcl/releases](https://github.com/PointCloudLibrary/pcl/releases&quot;&gt;PCL1.9.1&lt;/a&gt;&lt;br&gt;点击链接跳转Github下载，根据自己的环境选择 &lt;code&gt;win64&lt;/code&gt;或&lt;code&gt;win32&lt;/code&gt;,作者下载的是：&lt;code&gt;PCL-1.9.1-AllInOne-msvc2017-win64.exe&lt;/code&gt;&lt;br&gt;&lt;code&gt;pcl-1.9.1-pdb-msvc2017-win64.zip&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="环境配置" scheme="http://yoursite.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="PCL" scheme="http://yoursite.com/tags/PCL/"/>
    
      <category term="配置踩坑" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>图像灰度化和二值化</title>
    <link href="http://yoursite.com/2019/05/27/%E5%9B%BE%E5%83%8F%E8%A7%86%E8%A7%89/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%8C%96%E5%92%8C%E4%BA%8C%E5%80%BC%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/27/图像视觉/图像灰度化和二值化/</id>
    <published>2019-05-27T15:56:28.000Z</published>
    <updated>2019-09-30T12:48:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>彩色图片，对于21世纪的我们来说，已经不再是什么新鲜事物了。还记得，年幼时看的电视剧吗，少年包青天、天龙八部、射雕英雄传等等，脑海里的画面是如此清晰生动，可如今每当偶有兴致，重温这些经典时，画面已不再是印象中那般模样。不是我们的记忆模糊了，是我们的眼睛变“挑剔”了。</p><h1 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h1><p>为什么会有如此大的变化？原来，图片是由一个个像素组成的。像素是最小的图像单元，像素越多，呈现的画面就越清晰，由于过去技术的限制，图片的存储量相较于今天的技术十分有限。因此，旧时图片的像素个数较少，即分辨率较低，造成了我们视觉上“模糊”的观感。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;彩色图片，对于21世纪的我们来说，已经不再是什么新鲜事物了。还记得，年幼时看的电视剧吗，少年包青天、天龙八部、射雕英雄传等等，脑海里的画面是
      
    
    </summary>
    
    
      <category term="图像视觉" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="OpenCV" scheme="http://yoursite.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Kinect-V2-For-Windows-开发（一）：SDK+VS20XX环境搭建</title>
    <link href="http://yoursite.com/2019/05/21/Kinect%E5%BC%80%E5%8F%91/Kinect-V2-For-Windows-%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASDK+VS20XX%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/05/21/Kinect开发/Kinect-V2-For-Windows-开发（一）：SDK+VS20XX环境搭建/</id>
    <published>2019-05-21T05:05:25.000Z</published>
    <updated>2019-09-30T10:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>硕士期间用的最多的设备莫过于Kinect v2了。每当有学弟问到我如何去使用Kinect v2或者让我提供一些教程时，我都有些头疼。一方面，网上的教程过于繁多，让初学者摸不着头脑，无从下手；另一方面，环境配置不提，直接提供代码，让初学者很是头疼。为了方便他人，方便自己，特开此专题，介绍一下Kinect v2的简单用法，带初学者入门。</p><a id="more"></a><hr><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><strong>1台用于开发Kinect v2（可连接PC端）</strong></li><li><strong>安装<a href="[https://www.microsoft.com/en-us/download/details.aspx?id=44561](https://www.microsoft.com/en-us/download/details.aspx?id=44561">Kinect v2 SDK</a></strong></li><li><strong>安装编译器(可以使用VS系列)</strong></li></ul><hr><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ul><li><p><strong>打开VS20XX，新建空项目。右击<code>源文件-&gt;添加-&gt;新建项</code></strong><br><img src="http://pyklc92mt.bkt.clouddn.com/image/kinect_develop/1stwebp.jpg" alt></p></li><li><p><strong>单击菜单栏<code>项目-&gt;属性-&gt;VC++目录-&gt;包含目录-&gt;编辑</code></strong>,<strong>添加：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(KINECTSDK20_DIR)\inc</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://pyklc92mt.bkt.clouddn.com/image/kinect_develop/1stwebp%20%281%29.jpg" alt></p><ul><li><strong><code>VC++目录-&gt;库目录-&gt;编辑</code></strong>,<strong>添加：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(KINECTSDK20_DIR)\lib\x86</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://pyklc92mt.bkt.clouddn.com/image/kinect_develop/1stwebp%20%282%29.jpg" alt></p><ul><li><strong><code>链接器-&gt;输入-&gt;附加依赖项</code></strong>,<strong>添加：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kinect20.lib</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://pyklc92mt.bkt.clouddn.com/image/kinect_develop/1stwebp%20%283%29.jpg" alt></p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>至此，环境搭建完成。继续下一篇的学习吧!</strong></p><p><strong><em>如有任何问题或是书写纰漏，请给我留言，我会帮你们耐心解决。<br>感谢观看，希望对你们有所帮助！</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;硕士期间用的最多的设备莫过于Kinect v2了。每当有学弟问到我如何去使用Kinect v2或者让我提供一些教程时，我都有些头疼。一方面，网上的教程过于繁多，让初学者摸不着头脑，无从下手；另一方面，环境配置不提，直接提供代码，让初学者很是头疼。为了方便他人，方便自己，特开此专题，介绍一下Kinect v2的简单用法，带初学者入门。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kinect开发" scheme="http://yoursite.com/categories/Kinect%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Kinect" scheme="http://yoursite.com/tags/Kinect/"/>
    
      <category term="环境搭建" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>点云法向量估计原理及应用PCL</title>
    <link href="http://yoursite.com/2018/08/25/%E5%9B%BE%E5%83%8F%E8%A7%86%E8%A7%89/%E7%82%B9%E4%BA%91%E6%B3%95%E5%90%91%E9%87%8F%E4%BC%B0%E8%AE%A1%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8PCL/"/>
    <id>http://yoursite.com/2018/08/25/图像视觉/点云法向量估计原理及应用PCL/</id>
    <published>2018-08-24T16:31:57.000Z</published>
    <updated>2019-09-30T09:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>点云法向量估计这个问题，相信很多人在点云处理，曲面重建的过程中遇到过。<strong>表面法线是几何体面的重要属性。而点云数据集在真实物体的表面表现为一组定点样本。对点云数据集的每个点的法线估计，可以看作是对表面法线的近似推断。</strong>在开源库提供我们调用便利的同时，了解其实现原理也有利于我们对问题的深刻认识！<strong>格物要致知：）</strong></p><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><strong><em>确定表面一点法线的问题近似于估计表面的一个相切面法线的问题，因此转换过来以后就变成一个最小二乘法平面拟合估计问题。</em></strong></p><ul><li><p><strong>平面方程</strong></p><script type="math/tex; mode=display">cos\alpha·x+cos\beta·y+cos\gamma·z+p=0</script><p>$cos\alpha,cos\beta,cos\gamma$为平面上点$(x,y,z)$处法向量的方向余弦，$|p|$为原点到平面的距离。</p><script type="math/tex; mode=display">ax+by+cz=d(d\geq0),a^{2}+b^{2}+c^{2}=1</script><p>求平面方程即转化为求$a,b,c,d$四个参数。</p></li><li><strong>求解过程</strong></li></ul><p><strong>1. 待拟合平面点集$(x_i,y_i,z_i),i=1,2,…,n$</strong><br>待拟合的平面方程：<script type="math/tex">ax+by+cz=d(d\geq0),a^{2}+b^{2}+c^{2}=1</script><br>任意点到平面的距离：<script type="math/tex">d_i=|ax+by+cz-d|</script></p><p><strong>2. 要获得最佳拟合平面，则需要满足：</strong></p><script type="math/tex; mode=display">e=\sum^n_{i=1} d_i^2\to min</script><p>因此，转化为求解极值的问题，</p><script type="math/tex; mode=display">f=\sum^n_{i=1} d_i^2\space-\lambda(a^{2}+b^{2}+c^{2}-1)</script><p><strong>3. 分别对$d,a,b,c$求偏导</strong></p><script type="math/tex; mode=display">\frac{\partial f}{\partial d}=-2\sum^n_{i=1} (ax_i+by_i+cz_i-d)=0</script><script type="math/tex; mode=display">d=\frac{\sum ^{n}_{i=1}x_i}{n}a+\frac{\sum^{n}_{i=1}y_i}{n}b+\frac{\sum^{n}_{i=1}z_i}{n}c</script><p>将$d$带入任意点到平面的距离公式：</p><script type="math/tex; mode=display">\begin{equation}\begin{split}d_i&=|a(x_i-\frac{\sum ^{n}_{i=1}x_i}{n})+b(y_i-\frac{\sum ^{n}_{i=1}y_i}{n})+c(z_i-\frac{\sum ^{n}_{i=1}z_i}{n})|\\&=|a(x_i-\overline x)+b(y_i-\overline y)+c(z_i-\overline z)|\\\end{split}\end{equation}</script><p>继续求偏导</p><script type="math/tex; mode=display">\frac{\partial f}{\partial a}=2\sum^n_{i=1} (a(x_i-\overline x)+b(y_i-\overline y)+c(z_i-\overline z))(x_i-\overline x)-2\lambda a=0</script><p>令$\Delta x_i=x_i-\overline x,\Delta y_i=y_i-\overline y,\Delta z_i=z_i-\overline z$<br>则：</p><script type="math/tex; mode=display">\frac{\partial f}{\partial a}=2\sum^n_{i=1} (a\Delta x_i+b\Delta y_i+c\Delta z_i)\Delta x_i-2\lambda a=0</script><p>同理：<script type="math/tex">\frac{\partial f}{\partial b}=2\sum^n_{i=1} (a\Delta x_i+b\Delta y_i+c\Delta z_i)\Delta y_i-2\lambda b=0</script></p><script type="math/tex; mode=display">\frac{\partial f}{\partial c}=2\sum^n_{i=1} (a\Delta x_i+b\Delta y_i+c\Delta z_i)\Delta z_i-2\lambda c=0</script><p>将上述三式统一：</p><script type="math/tex; mode=display">\begin{pmatrix}\sum \Delta x_i\Delta x_i & \sum \Delta x_i\Delta y_i &\sum \Delta x_i\Delta z_i\\ \sum  \Delta x_i\Delta y_i & \sum \Delta y_i\Delta y_i &\sum \Delta y_i\Delta z_i\\\sum \Delta x_i\Delta z_i & \sum \Delta y_i\Delta z_i &\sum \Delta z_i\Delta z_i \end{pmatrix}\begin{pmatrix}a  \\ b \\c \end{pmatrix}=\lambda\begin{pmatrix}a\\b\\c \end{pmatrix}</script><p>易得：</p><script type="math/tex; mode=display">Ax=\lambda x</script><p>即转化到了求解矩阵A的特征值与特征向量的问题，矩阵$A$即为n个点的协方差矩阵。$(a,b,c)^T$即为该矩阵的一个特征向量。</p><p><strong>4. 求最小特征向量</strong><br>如上所示，求得的特征向量可能不止一个，那么如何来选取特征向量，使得求得法向量为最佳拟合平面的法向量呢？<br>由$a^2+b^2+c^2=1,\Rightarrow(x,x)=1$(内积形式)，<br>$Ax=\lambda x,\Rightarrow (Ax,x)=(\lambda x ,x),\Rightarrow \lambda=(Ax,x)$,<br>$\Rightarrow \lambda=\sum_{i=0}^{n}(a\Delta x_i+b\Delta y_i+c\Delta z_i)^2,$<br>$\Rightarrow \lambda=\sum_{i=0}^{n}d_i^2$<br>由$e=\sum^n_{i=1} d_i^2\to min,\lambda \to min$<br>因此，<strong>最小特征值对应的特征向量即为法向量</strong></p><hr><h1 id="程序应用"><a href="#程序应用" class="headerlink" title="程序应用"></a>程序应用</h1><ul><li><p><strong>PCL中的NormalEstimation</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    #include &lt;pcl/point_types.h&gt;</span><br><span class="line">    #include &lt;pcl/features/normal_3d.h&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);</span><br><span class="line"></span><br><span class="line">  ... read, pass in or create a point cloud ...</span><br><span class="line"></span><br><span class="line">  // Create the normal estimation class, and pass the input dataset to it</span><br><span class="line">  pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">  ne.setInputCloud (cloud);</span><br><span class="line"></span><br><span class="line">  // Create an empty kdtree representation, and pass it to the normal estimation object.</span><br><span class="line">  // Its content will be filled inside the object, based on the given input dataset (as no other search surface is given).</span><br><span class="line">  pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree (new pcl::search::KdTree&lt;pcl::PointXYZ&gt; ());</span><br><span class="line">  ne.setSearchMethod (tree);</span><br><span class="line"></span><br><span class="line">  // Output datasets</span><br><span class="line">  pcl::PointCloud&lt;pcl::Normal&gt;::Ptr cloud_normals (new pcl::PointCloud&lt;pcl::Normal&gt;);</span><br><span class="line"></span><br><span class="line">  // Use all neighbors in a sphere of radius 3cm</span><br><span class="line">  ne.setRadiusSearch (0.03);</span><br><span class="line"></span><br><span class="line">  // Compute the features</span><br><span class="line">  ne.compute (*cloud_normals);</span><br><span class="line"></span><br><span class="line">  // cloud_normals-&gt;points.size () should have the same size as the input cloud-&gt;points.size ()*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>OpenMP加速法线估计</strong><br>PCL提供了表面法线估计的加速实现，基于OpenMP使用多核/多线程来加速计算。 该类的名称是pcl :: NormalEstimationOMP，其API与单线程pcl :: NormalEstimation 100％兼容。 在具有8个内核的系统上，一般计算时间可以加快6-8倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">include &lt;pcl/point_types.h&gt;</span><br><span class="line">#include &lt;pcl/features/normal_3d_omp.h&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);</span><br><span class="line"></span><br><span class="line">  ... read, pass in or create a point cloud ...</span><br><span class="line"></span><br><span class="line">  // Create the normal estimation class, and pass the input dataset to it</span><br><span class="line">  pcl::NormalEstimationOMP&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">  ne.setNumberOfThreads(12);  // 手动设置线程数，否则提示错误</span><br><span class="line">  ne.setInputCloud (cloud);</span><br><span class="line"></span><br><span class="line">  // Create an empty kdtree representation, and pass it to the normal estimation object.</span><br><span class="line">  // Its content will be filled inside the object, based on the given input dataset (as no other search surface is given).</span><br><span class="line">  pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree (new pcl::search::KdTree&lt;pcl::PointXYZ&gt; ());</span><br><span class="line">  ne.setSearchMethod (tree);</span><br><span class="line"></span><br><span class="line">  // Output datasets</span><br><span class="line">  pcl::PointCloud&lt;pcl::Normal&gt;::Ptr cloud_normals (new pcl::PointCloud&lt;pcl::Normal&gt;);</span><br><span class="line"></span><br><span class="line">  // Use all neighbors in a sphere of radius 3cm</span><br><span class="line">  ne.setRadiusSearch (0.03);</span><br><span class="line"></span><br><span class="line">  // Compute the features</span><br><span class="line">  ne.compute (*cloud_normals);</span><br><span class="line"></span><br><span class="line">  // cloud_normals-&gt;points.size () should have the same size as the input cloud-&gt;points.size ()*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;点云法向量估计这个问题，相信很多人在点云处理，曲面重建的过程中遇到过。&lt;strong&gt;表面法线是几何体面的重要属性。而点云数据集在真实物体的表面表现为一组定点样本。对点云数据集的每个点的法线估计，可以看作是对表面法线的近似推断。&lt;/strong&gt;在开源库提供我们调用便利的同时，了解其实现原理也有利于我们对问题的深刻认识！&lt;strong&gt;格物要致知：）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像视觉" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="点云" scheme="http://yoursite.com/tags/%E7%82%B9%E4%BA%91/"/>
    
      <category term="PCL" scheme="http://yoursite.com/tags/PCL/"/>
    
  </entry>
  
</feed>
